<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Capture & Recadrage - Camera / Video → Recadrage exact</title>
<style>
body { font-family: system-ui, -apple-system, "Helvetica Neue", Arial; margin:0; padding:0; display:flex; flex-direction:column; height:100vh; background:#f7f7f7; }
header { padding:10px; background:#0a74da; color:white; text-align:center; }
main { display:flex; flex:1; gap:10px; padding:10px; box-sizing:border-box; flex-wrap:wrap; justify-content:center; align-items:flex-start; }
.col { flex:1 1 320px; min-width:280px; max-width:720px; display:flex; flex-direction:column; gap:8px; }
video, canvas { width:100%; height:auto; border-radius:8px; background:#111; }
button { padding:10px 14px; border-radius:8px; border:0; background:#0a74da; color:white; font-weight:600; cursor:pointer; }
.controls { display:flex; gap:8px; flex-wrap:wrap; }
.info { font-size:0.9rem; color:#333; }
footer { padding:8px; text-align:center; font-size:0.9rem; color:#666; }
#loader { font-size:0.9rem; color:#444; }
.small { font-size:0.85rem; color:#444; }
</style>
</head>
<body>
<header>
  <h1>Capture & Recadrage Exact</h1>
  <div class="small">Détecte une zone colorée, recadre exactement, et permet téléchargement / QR scan.</div>
</header>

<main>
  <div class="col">
    <video id="video" autoplay playsinline></video>
    <div class="controls">
      <button id="startBtn">Démarrer caméra</button>
      <button id="selectVideoBtn">Sélectionner vidéo</button>
      <input type="file" id="videoInput" accept="video/*" style="display:none">
      <button id="captureBtn" disabled>Capturer</button>
      <button id="toggleCamBtn" disabled>Changer caméra</button>
      <button id="downloadWarpBtn" disabled>Télécharger recadré</button>
    </div>
    <div id="loader">Chargement OpenCV...</div>
    <div class="info" id="status">Statut : prêt</div>
  </div>

  <div class="col">
    <canvas id="canvasCapture"></canvas>
    <canvas id="canvasWarp"></canvas>
    <div class="controls">
      <button id="decodeQRBtn" disabled>Scanner QR (jsQR)</button>
      <button id="downloadRawBtn" disabled>Télécharger PNG</button>
    </div>
    <div class="info" id="result">Résultat : —</div>
  </div>
</main>

<footer>
  Fonctionne mieux sur HTTPS (GitHub Pages, localhost...). OpenCV peut prendre quelques secondes à charger.
</footer>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

<script>
let video = document.getElementById('video');
let canvasCapture = document.getElementById('canvasCapture');
let canvasWarp = document.getElementById('canvasWarp');
let ctxCap = canvasCapture.getContext('2d');
let ctxWarp = canvasWarp.getContext('2d');

let startBtn = document.getElementById('startBtn');
let selectVideoBtn = document.getElementById('selectVideoBtn');
let videoInput = document.getElementById('videoInput');
let captureBtn = document.getElementById('captureBtn');
let toggleCamBtn = document.getElementById('toggleCamBtn');
let decodeQRBtn = document.getElementById('decodeQRBtn');
let downloadWarpBtn = document.getElementById('downloadWarpBtn');
let downloadRawBtn = document.getElementById('downloadRawBtn');

let statusEl = document.getElementById('status');
let resultEl = document.getElementById('result');
let loader = document.getElementById('loader');

let stream = null;
let useFront = false;
let cvReady = false;

function onOpenCvReady() {
  loader.innerText = 'OpenCV prêt.';
  cvReady = true;
  startBtn.disabled = false;
  selectVideoBtn.disabled = false;
}

// --- Caméra ---
startBtn.addEventListener('click', async () => {
  startBtn.disabled = true;
  status('Demande d’accès caméra...');
  await startCamera();
});

toggleCamBtn.addEventListener('click', async () => {
  useFront = !useFront;
  await startCamera();
});

async function startCamera() {
  if (stream) stream.getTracks().forEach(t => t.stop());
  const constraints = { audio:false, video:{ facingMode: useFront?'user':'environment', width:{ideal:1280}, height:{ideal:720} }};
  try {
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
    status('Caméra active.');
    captureBtn.disabled = false;
    toggleCamBtn.disabled = false;
  } catch (err) {
    status('Erreur caméra: ' + err.message);
    startBtn.disabled = false;
  }
}

// --- Sélection vidéo ---
selectVideoBtn.addEventListener('click', ()=> videoInput.click());
videoInput.addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  const url = URL.createObjectURL(file);
  video.srcObject = null;
  video.src = url;
  video.play();
  captureBtn.disabled = false;
  toggleCamBtn.disabled = true;
  status('Vidéo chargée.');
});

// --- Capture et recadrage exact ---
captureBtn.addEventListener('click', ()=> {
  if(!cvReady) return status('OpenCV pas prêt.');

  let w = video.videoWidth, h = video.videoHeight;
  canvasCapture.width = w; canvasCapture.height = h;
  ctxCap.drawImage(video,0,0,w,h);
  let src = cv.imread(canvasCapture);

  try {
    // --- Masque pixels colorés ---
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
    let mask = new cv.Mat();
    cv.threshold(gray, mask, 10, 255, cv.THRESH_BINARY);

    // --- Contours pour recadrage ---
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    if(contours.size() === 0) {
      status('Aucune zone colorée détectée.');
      src.delete(); gray.delete(); mask.delete(); contours.delete(); hierarchy.delete();
      return;
    }

    // Plus grand contour
    let maxArea = 0, maxCnt = null;
    for(let i=0;i<contours.size();i++){
      let cnt = contours.get(i);
      let area = cv.contourArea(cnt);
      if(area > maxArea){
        if(maxCnt) maxCnt.delete();
        maxArea = area;
        maxCnt = cnt;
      } else cnt.delete();
    }

    let rect = cv.boundingRect(maxCnt);
    let crop = src.roi(rect);

    canvasWarp.width = rect.width;
    canvasWarp.height = rect.height;
    cv.imshow('canvasWarp', crop);

    downloadWarpBtn.disabled = false;
    downloadRawBtn.disabled = false;
    decodeQRBtn.disabled = false;
    resultEl.innerText = `Zone extraite (${rect.width}x${rect.height})`;

    // Libération
    gray.delete(); mask.delete(); contours.delete(); hierarchy.delete(); crop.delete();
    maxCnt.delete(); src.delete();
  } catch(e){
    console.error(e);
    status('Erreur: '+e);
    src.delete();
  }
});

// --- QR ---
decodeQRBtn.addEventListener('click', ()=>{
  if(canvasWarp.width===0) return status('Rien à scanner.');
  let imgData = ctxWarp.getImageData(0,0,canvasWarp.width,canvasWarp.height);
  let code = jsQR(imgData.data,imgData.width,imgData.height);
  if(code){
    resultEl.innerText = 'QR décodé : ' + code.data;
    status('QR trouvé.');
  } else {
    resultEl.innerText = 'Aucun QR détecté.';
    status('Aucun QR.');
  }
});

// --- Téléchargement ---
function saveCanvas(canvas, filename){
  canvas.toBlob(blob=>{
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    setTimeout(()=>{ a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); },100);
  }, "image/png");
}

downloadWarpBtn.addEventListener('click', ()=> saveCanvas(canvasWarp,'extrait.png'));
downloadRawBtn.addEventListener('click', ()=> saveCanvas(canvasCapture,'capture.png'));

function status(t){ statusEl.innerText = 'Statut : ' + t; }
</script>
</body>
</html>
